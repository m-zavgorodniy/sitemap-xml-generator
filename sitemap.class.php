<?
/**
 * Generates XML sitemap for search engines.
 *
 * XML is generated by crawling the site with cURL.
 *
 * @copyright maxim zavgorodniy 16/05/2020
 * @version 1.0.0
 */
class SiteMap {
  private $http_site;
  private $max_depth;
  private $abs_path_to_cacert;

  // all the urls we crawled through
  private $urls = [];

  /**
   * @param  string       $http_site            The site we want a sitemap for, with protocol (eg. https://example.com)
   * @param  string|null  $abs_path_to_cacert   (optional) Absolute path to cacert.pem (usually) file for safe crawling over HTTPS
   * @param  int|null     $max_depth            (optional) Depth of crawling
   */
  function __construct($http_site, $abs_path_to_cacert = null, $max_depth = 5) {
    $this->http_site = rtrim($this->get_real_url($http_site), '/');
    $this->max_depth = $max_depth;

    $this->set_abs_path_to_cacert($abs_path_to_cacert);
  }

  /**
   * Generates XML
   */
  public function generate() {
    // it may take long
    set_time_limit(0);

    // start from site root
    $this->get_links();
    $this->urls = array_unique(array_filter($this->urls));

    // https://support.google.com/webmasters/answer/183668?hl=en
    // Google ignores <priority> and <changefreq> values, so don't bother adding them.
    // Google reads the <lastmod> value, but if you misrepresent this value, we will stop reading it
    // So do we, only 'loc' that countt
    $res = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
    $res .= "<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n";
    foreach ($this->urls as $url) {
      $loc = (strpos($url, $this->http_site) !== 0 ? $this->http_site : '') . $url;
      $res .= "<url>\n";
      $res .= "  <loc>{$loc}</loc>\n";
      $res .= "</url>\n";
    }
    $res .= "</urlset>";

    return $res;
  }

  // crawls the site
  private function get_links($url='/', $depth=1) {
    // the depth increases on each recursive call
    if ($depth > $this->max_depth) {
      return;
    }

    // we don't want to get one url's content twice
    static $urls_processed = [];
    if (in_array($url, $urls_processed)) {
      return;
    }

    // get page contents
    $urls_processed[] = $url;
    $contents = $this->get_contents($url);

    // check if the page is "noindex, nofollow"
    if ($this->check_page_noindex($contents)) {
      $key = array_search($url, $this->urls);
      if ($key !== false) {
        unset($this->urls[$key]);
      }
      return;
    }

    // exctact <a ...> links from the page contents
    $links = [];
    preg_match_all('/<a\s[^>]*/i', $contents, $links);

    foreach ($links[0] as $link) {
      // if <a ...> is of rel="nofollow" do not follow
      if (preg_match('/\brel=["\']nofollow["\']/i', $link)) {
        continue;
      }

      // extract url (href) from the link
      if (preg_match('/\bhref=["\']([^("\')]*)/i', $link, $matches)) {
        $link_url = $matches[1];
        // follow only the links within the site
        if (!(strpos($link_url, '/') === 0 || strpos($link_url, '?') === 0 || strpos($link_url, '.') === 0 || strpos($link_url, $this->http_site) === 0)) {
          continue;
        }
        // relative links might need some more processing
        if (strpos($link_url, '?') === 0 || strpos($link_url, '.') === 0) {
          $link_path = explode('?', $url)[0];
          if (strpos($link_url, '.') === 0) {
            $link_url = str_replace('/./', '/', rtrim($link_path, '/') . '/' . $link_url);
          } else {
            $link_url = $link_path . $link_url;
          }
        }
        // add the url onto the list but a real one ater followinf all redirects, that is handled by get_real_url()
        $this->urls[] = $this->get_real_url($link_url);
      }
    }

    // next recursive step - get the contents and urls to follow for all the pages on the url list
    foreach ($this->urls as $next_level_url) {
      $this->get_links($next_level_url, $depth+1);
    }
  }

  // gets page contents or just url if we want just to trace redirects
  private function get_contents($url, $return_url = false) {
    $options = $this->set_curl_options($url, $return_url);

    $ch = curl_init();
    curl_setopt_array($ch, $options);
    $result = curl_exec($ch);

    $curl_info = curl_getinfo($ch);
    if (!empty($curl_info['redirect_url'])) {
      // follow the redirect recursively
      $result = $this->get_contents($curl_info['redirect_url'], $return_url);
      if ($return_url) {
        $url = $result;
      }
    } else if (empty($result) || $curl_info['http_code'] != 200) {
      trigger_error(curl_error($ch));
      if ($return_url) {
        $url = '';
      }
    }

    curl_close($ch);
    return $return_url ? $url : $result;
  }

  // returns url after its redirects traced
  private function get_real_url($url) {
    return $this->get_contents($url, true);
  }

  // checks if a page has a 'noindex, nofollow' meta
  private function check_page_noindex($contents) {
    $metas = [];
    if (preg_match_all('/<meta\s.*\bname=["\']robots["\'][^>]*/i', $contents, $metas));
    foreach ($metas[0] as $meta) {
      if (stripos($meta, 'noindex') !== false || stripos($meta, 'nofollow') !== false) {
        return true;
      }
    }
    return false;
  }

  // sets cURL options
  private function set_curl_options($url, $headers_only = false) {
    $options = [
      CURLOPT_URL => (strpos($url, $this->http_site) !== 0 ? $this->http_site : '') . $url,
      CURLOPT_RETURNTRANSFER => true,
      CURLOPT_HEADER => true,
      CURLOPT_USERAGENT => 'sitemap generator',
    ];

    if ($headers_only) {
      $options[CURLOPT_NOBODY] = true;
    }

    // ideally we want cacert.pem
    // but as a trade off can turn off ssl verification (not recommended!)
    if (!empty($this->abs_path_to_cacert)) {
      $options[CURLOPT_CAINFO] = $this->abs_path_to_cacert;
    } else {
      $options[CURLOPT_SSL_VERIFYPEER] = 0;
    }

    return $options;
  }

  // handles the path to cacert.pem - checks if it exists; triggers a warning if it's not defined
  private function set_abs_path_to_cacert($abs_path_to_cacert) {
    if (!empty($abs_path_to_cacert)) {
      if (!file_exists($abs_path_to_cacert)) {
        trigger_error("CA certs file {$abs_path_to_cacert} does not exist.", E_USER_ERROR);
      }
      $this->abs_path_to_cacert = $abs_path_to_cacert;
    } else {
      trigger_error("CA certs file is not defined, running Curl with CURLOPT_SSL_VERIFYPEER=0 that may be a potential security issue.", E_USER_WARNING);
    }
  }
}
?>
